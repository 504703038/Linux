---
title: 板子
categories: 板子
mathjax: true
---

## 1、数论

### 1.1GCD&&LCM

~~~c++
ll gcd(ll a,ll b)
{
    return b?gcd(b,a%b):a;
}
ll lcm(ll a,ll b)
{
    return a*b/gcd(a,b);
}
~~~

### 1.2扩展欧几里德

~~~c++
ll extgcd(ll a,ll b,ll &x, ll &y)  // 求解 ax + by = gcd(a,b)
{
    ll res=0;
    if (!b) res=a,x=1,y=0;
    else res=extgcd(b,a%b,y,x),y-=(a/b)*x;
    return res;                    //返回a与b的最大公约数
}           //x,y为ax+by=gcd(a,b)的一组可行解
bool Indefinite_equation(ll a,ll b,ll c,ll &x,ll &y) // 求解 ax + by = c
{
    ll d=extgcd(a,b,x,y);
    ll k=c/d;
    ll bd=fabs(b/d);
    if (c%d) return 0;
    x=k*x;
    //x=x+t*(b/d);     通解
    y=(c-a*x)/b;
	return 1;
}
~~~

### 1.3快速幂

#### 1.3.1整数快速幂

~~~c++
ll qpow(ll a,ll k,ll MOD)
{
    ll res=1;
    while(k>0)
    {
        if (k&1) res=res*a%MOD;
        a=a*a%MOD;
        k>>=1;
    }
    return res;
}
~~~

#### 1.3.2矩阵快速幂

~~~c++
// POJ - 3070
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#define ll long long
using namespace std;
const int MAXN=10,MOD=1e4;
int n=2;
struct Matrix
{
    ll a[MAXN][MAXN];
    void output()
    {
        for(int i=1;i<=n;i++)
        {
            for(int j=1;j<=n;j++)
                printf("%lld ",a[i][j]);
            printf("\n");
        }
    }
}e;
Matrix mul(Matrix a,Matrix b)
{
    Matrix res;
    ll x;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            x=0;
            for(int k=1;k<=n;k++)
            {
                x+=(a.a[i][k]*b.a[k][j])%MOD;
            }
            res.a[i][j]=x%MOD;
        }
    }
    return res;
}
Matrix Matrix_pow(Matrix a,int k)
{
    Matrix res;
    res.a[1][1]=res.a[2][2]=1;
    res.a[1][2]=res.a[2][1]=0;
    while(k)
    {
        if (k&1) res=mul(res,a);
        k>>=1;
        a=mul(a,a);
    }
    return res;
}
int main()
{
    while(1)
    {
        int k;
        scanf("%d",&k);
        if (k<0) break;
        Matrix ans;
        ans.a[1][1]=ans.a[1][2]=ans.a[2][1]=1;
        ans.a[2][2]=0;
        ans=Matrix_pow(ans,k);
        //ans.output();
        printf("%lld\n",ans.a[1][2]);
    }
}
~~~

### 1.4质因数分解

~~~c++
void divide(int n,int *a,int *cnt)//a数组为质因子数组,cnt数组为对应质因子的个数
{
    a[0]=0;
    int x=n;
    for(int i=2;i*i<=n;i++)
    {
        if (x%i==0) a[++a[0]]=i;
        while(x%i==0) x/=i,cnt[a[0]]++;
    }
    if (x>1) a[++a[0]]=x,cnt[a[0]]++;
}


~~~

### 1.5素数

#### 1.5.1素筛

~~~c++
const int N=1e8+10;
int prime[N];      //素数数组，prime[i]表示第i个素数
bool v[N],u[N];  //标记数组
int Eratosthenes_sieve(int n) //埃氏筛法
{
    int tot=0;
    memset(v,1,sizeof(v));
    v[0]=v[1]=0;
    for(int i=2;i<=n;i++)
    {
        if (v[i])
        {
            prime[++tot]=i;
            for(int j=i+i;j<=n;j+=i) v[j]=0;
        }
    }
    return tot;     //返回素数个数
}
///////////////分割线//////////////////////////
int Linear_sieve(int n) //线性筛法
{
    int tot=0;
    memset(v,1,sizeof(v));
    for(int i=2;i<=n;i++)
    {
        if (v[i]) prime[++tot]=i;
        for(int j=1;j<=tot && prime[j]*i<=n;j++)
        {
            v[prime[j]*i]=0;
            if (i%prime[j]==0) break;
        }
    }
    return tot;   //返回素数个数
}
///////////////分割线//////////////////////////
int Segment_sieve(ll a,ll b)   //区间筛法  区间[a,b)
{
    if (a<2) a=2;
    for(int i=0;(ll)i*i<b;i++) u[i]=1;
    for(int i=0;i<b-a;i++) v[i]=1;
    for(int i=2;(ll)i*i<b;i++)
    {
        if (u[i])
        {
            for(int j=2*i;(ll)j*j<b;j+=i) u[i]=0;
            for(ll j=max(2ll,(a+i-1)/i)*i;j<b;j+=i) v[j-a]=0;
        }
    }
    int tot=0;
    for(int i=0;i<b-a;i++)
        if(v[i]) prime[++tot]=a+i;
    return tot;     //返回区间的素数个数
}
~~~

#### 1.5.2判素

~~~c++
//貌似比较慢
ll qmul(ll a,ll b,ll MOD)   //快速乘
{
    ll res=0;
    while(b)
    {
        if (b&1) res=(res+a)%MOD;
        a=(a+a)%MOD;
        b>>=1;
    }
    return res;
}
ll qpow(ll a,ll b,ll MOD)   //快速幂
{
    ll res=1;
    while(b)
    {
        if (b&1) res=qmul(res,a,MOD);
        a=qmul(a,a,MOD);
        b>>=1;
    }
    return res;
}
bool Miller_Rabin(ll n)     //Miller_Rabin判素
{
    if (n==2) return 1;
    if (n<2 || !(n&1)) return 0;
    ll m=n-1,k=0;
    while(!(m&1))
    {
        k++;
        m>>=1;
    }
    for(int i=1;i<=10;i++) //10为Miller-Rabin测试迭代次数
    {
        ll a=rand()%(n-1)+1;
        ll x=qpow(a,m,n);
        ll y;
        for(int j=1;j<=k;j++)
        {
            y=qmul(x,x,n);
            if (y==1 && x!=1 && x!=n-1) return 0;
            x=y;
        }
        if (y!=1) return 0;
    }
    return 1;
}
//////////////分割线//////////////////////
//网上的一种快速判素
bool prime (int num)//快速判断素数
{
  if (num == 2 || num == 3 || num == 5)
    return true;
  if (num % 2 == 0 || num % 3 == 0 || num % 5 == 0 || num == 1)
    return false;

  unsigned long c = 7;
  int maxc = int (sqrt((double)num));
  while (c <= maxc)
    {
      if (num % c == 0)
        return false;
      c += 4;
      if (num % c == 0)
        return false;
      c += 2;
      if (num % c == 0)
        return false;
      c += 4;
      if (num % c == 0)
        return false;
      c += 2;
      if (num % c == 0)
        return false;
      c += 4;
      if (num % c == 0)
        return false;
      c += 6;
      if (num % c == 0)
        return false;
      c += 2;
      if (num % c == 0)
        return false;
      c += 6;
    }
  return true;
}
~~~

### 1.6中国剩余定理

~~~c++
///////////////模数两两互质/////////////////
ll extgcd(ll a,ll b,ll &x,ll &y)
{
    ll res=0;
    if (!b) res=a,x=1,y=0;
    else res=extgcd(b,a%b,y,x),y-=(a/b)*x;
    return res;
}
ll CRT(int n,ll *a,ll *m)//a数组为余数，m数组为模数
{
    ll y,x,res=0;
    for(int i=1;i<=3;i++)
    {
        ll w=lcm/m[i];	//lcm为模数的乘积
        extgcd(w,m[i],x,y);
        res=(res+(x*w*a[i])%lcm)%lcm;
    }
    while(res<0) res+=lcm;
    return res;
}

//////////////////分割线/////////////////
//////////////模数不两两互质///////////////
ll gcd(ll a,ll b)
{
    return b?gcd(b,a%b):a;
}
ll extgcd(ll a,ll b,ll &x,ll &y)
{
    ll res=0;
    if (!b) res=a,x=1,y=0;
    else res=extgcd(b,a%b,y,x),y-=(a/b)*x;
    return res;
}
ll inv(ll a,ll p)//a在模p乘法下的逆元,没有返回-1
{
    ll x,y;
    ll d=extgcd(a,p,x,y);
    if (d!=1) return -1;
    return (x%p+p)%p;
}
bool uni(ll a1,ll m1,ll a2,ll m2,ll &a3,ll &m3)//合并方程
{
    ll d=gcd(m1,m2);
    ll c=a2-a1;
    if (c%d) return 0;
    c=(c%m2+m2)%m2;
    c/=d;
    m1/=d;
    m2/=d;
    c*=inv(m1,m2);
    c%=m2;
    c*=m1*d;
    c+=a1;
    m3=m1*m2*d;
    a3=(c%m3+m3)%m3;
    return 1;
}
ll CRT_Noncoprime(int n,ll *a,ll *m)//求模线性方程组x=ai(mod mi),mi可以不互质
{
    ll a1=a[1],m1=m[1];
    ll a2,m2;
    for(int i=2;i<=n;i++)
    {
        ll aa,mm;
        a2=a[i],m2=m[i];
        if (!uni(a1,m1,a2,m2,aa,mm)) return -1;
        a1=aa,m1=mm;
    }
    return (a1%m1+m1)%m1;
}
~~~

### 1.7组合数

~~~c++
//n<1e9,m<1e4
ll qpow(ll a,ll k)
{
	ll res=1;
	while(k)
	{
		if (k&1) res=res*a%MOD;
		k>>=1;
		a=a*a%MOD;
	}
	return res;
}
ll C(ll n,ll m)
{
  ll res=1,mo=1;
  for (int i=1;i<=m;i++)
  {
    res=res*(n-m+i)%MOD;
    mo=mo*i%MOD;
  }
  return res*qpow(mo,MOD-2)%MOD;
}
ll Lucas(ll n,ll m)
{
	if (n<m) return 0;
	if (m==0) return 1;
	return C(n%MOD,m%MOD)*Lucas(n/MOD,m/MOD)%MOD;
}

///////////////分割线////////////////////
//n,m<1e6
const int N=2e6+10;
ll fac[N],ifac[N];
ll qpow(ll x,ll k)
{
    ll res=1;
    while(k)
    {
        if (k&1) res=res*x%MOD;
        k>>=1;
        x=x*x%MOD;
    }
    return res;
}
ll inv(ll x){return qpow(x,MOD-2);}
ll C(int n,int m)
{
    if (m>n || m<0 || n<0) return 0;
    if (m==0) return 1;
    return fac[n]*ifac[m]%MOD*ifac[n-m]%MOD;
}
void prepare()
{
    fac[0]=ifac[0]=1;
    for(int i=1;i<=1e6;i++)
    {
        fac[i]=fac[i-1]*i%MOD;
        ifac[i]=inv(fac[i]);
    }
}
~~~





## 2、字符串

### 2.1KMP

~~~c++
//HDU - 2203
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#define ll long long
using namespace std;
const int N=2e5+20;
char a[N],b[N];
int la,lb,nxt[N];
void get_next(char* s,int* nxt)
{
    int n=strlen(s);
    int j=0;
    nxt[0]=nxt[1]=0;
    for(int i=1;i<n;i++)
    {
        while(j>0 && s[i]!=s[j]) j=nxt[j];
        if (s[i]==s[j]) j++;
        nxt[i+1]=j;
    }
}
int count_str(char* a,char* b,int* nxt)
{
    int j=0,res=0;
    int n=strlen(a),m=strlen(b);
    for(int i=0;i<n;i++)
    {
        while(j>0 && a[i]!=b[j]) j=nxt[j];
        if (a[i]==b[j]) j++;
        if (j==m)
        {
            res++,j=nxt[j];
        }
    }
    return res;
}
int main()
{
    while(std::cin>>a)
    {
        std::cin>>b;
        la=strlen(a);
        lb=strlen(b);
        if (la<lb) {printf("no\n");continue;}
        for(int i=0;i<la;i++)
        {
            a[i+la]=a[i];
        }
        la*=2;
        get_next(b,nxt);
        if (count_str(a,b,nxt))
        printf("yes\n");
        else printf("no\n");
    }
}
~~~

### 2.2Manacher

~~~c++
//HDU - 3068
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#define ll long long
using namespace std;
const int N=2e5;
char s[N],ss[2*N];
int p[2*N];
int get_new_string(char* s,char* ss)
{
    int l=strlen(s);
    ss[0]='$';
    ss[1]='#';
    int j=2;
    for(int i=0;i<l;i++)
    {
        ss[j++]=s[i];
        ss[j++]='#';
    }
    ss[j]='\0';
    return j;
}
int Manacher(char* s,char* ss)
{
    int l=get_new_string(s,ss);
    int maxlen=-1;
    int id;
    int mx=0;
    for(int i=1;i<l;i++)
    {
        if (i<mx) p[i]=std::min(p[2*id-i],mx-i);
        else p[i]=1;
        while(ss[i-p[i]]==ss[i+p[i]]) p[i]++;
        if (mx<i+p[i])
        {
            id=i;
            mx=i+p[i];
        }
        maxlen=std::max(maxlen,p[i]-1);
    }
    return maxlen;
}
int main()
{
    while(~scanf("%s",&s))
    {
        memset(p,0,sizeof(p));
        printf("%d\n",Manacher(s,ss));
    }
}
~~~

### 2.3后缀数组

~~~c++
//洛谷P3809
#include <iostream>
#include <cstdio>
#include <cstring>
#define ll long long
const int maxn=1e6+10;
using namespace std;
char s[maxn];
int x[maxn],y[maxn],c[maxn],sa[maxn],rk[maxn],height[maxn],wt[30];
int n,m;
void putout(int x)
{
    if (!x)
    {
        putchar(48);
        return;
    }
    register int l=0;
    while(x) wt[++l]=x%10,x/10;
    while(l) putchar(wt[l--]+48);
}
void get_SA()
{
    for(int i=1;i<=n;++i) ++c[x[i]=s[i]];

    for(int i=2;i<=m;++i) c[i]+=c[i-1];
    for(int i=n;i>=1;--i) sa[c[x[i]]--]=i;
    for(int k=1;k<=n;k<<=1)
    {
        int num=0;
        for(int i=n-k+1;i<=n;++i) y[++num]=i;
        for(int i=1;i<=n;++i) if (sa[i]>k) y[++num]=sa[i]-k;
        for(int i=1;i<=m;++i) c[i]=0;
        for(int i=1;i<=n;++i) ++c[x[i]];
        for(int i=2;i<=m;++i) c[i]+=c[i-1];
        for(int i=n;i>=1;--i) sa[c[x[y[i]]]--]=y[i],y[i]=0;
        swap(x,y);
        x[sa[1]]=1;
        num=1;
        for(int i=2;i<=n;++i)
            x[sa[i]]=(y[sa[i]]==y[sa[i-1]] && y[sa[i]+k]==y[sa[i-1]]) ? num:++num;
        if (num==n) break;
        m=num;
    }
    for(int i=1;i<=n;++i) putout(sa[i]),putchar(' ');
}
int get_height()
{
    int k=0;
    for(int i=1;i<=n;i++) rk[sa[i]]=i;
    for(int i=1;i<=n;++i)
    {
        if (rk[i]==1) continue;
        if(k)  --k;
        int j=sa[rk[i]-1];
        while(j+k<=n && i+k<=n && s[i+k]==s[j+k]) ++k;
        height[rk[i]]=k;
    }
    putchar(10);
    for(int i=1;i<=n;++i) putout(height[i]),putchar(' ');
}
int main()
{
    cin>>(s+1);
    n=strlen(s+1);
    m=122;
    get_SA();
}
~~~





## 3、平面几何

### 3.0

####  3.0.1点积与叉积

叉积和点积的几何意义： 
叉积：可以求出一个点与一条线所构成的三角形面积。 
点积：可以求出一条向量在另一条上的投影长度。 

~~~c++

~~~

#### 3.0.2整点多边形

整点多边形是指顶点的横纵坐标均为整数,由外积导出的面积计算公式可以看出,整点多边形的面积或为整数,或为整数/2.
Pick公式：$$整点多边形的面积=内部整点个数+边上的整点个数/2-1$$. 

#### 3.0.3使用叉积计算多边形面积

~~~c++
//POJ - 1654
#include <cstdio>
#include <cstring>
#define ll long long
using namespace std;
const int N=1e6+10;
char s[N];
int l;
struct P {
    int x,y;
    P(){}
    P(int x,int y):x(x),y(y){}
    P operator -(const P &a)const{
        return P(x-a.x,y-a.y);
    }
    P operator +(const P &a)const{
        return P(x+a.x,y+a.y);
    }
};
P getP(P o,char c)
{
    P res;
    switch(c)
    {
        case '1': {res=o+P(-1,-1);break;}
        case '2': {res=o+P(0,-1);break;}
        case '3': {res=o+P(1,-1);break;}
        case '4': {res=o+P(-1,0);break;}
        case '5': {res=o+P(0,0);break;}
        case '6': {res=o+P(1,0);break;}
        case '7': {res=o+P(-1,1);break;}
        case '8': {res=o+P(0,1);break;}
        case '9': {res=o+P(1,1);break;}
    }
    return res;
}
ll cov(P a,P b) {return 1LL*(a.x*b.y-a.y*b.x);}
ll solve()//计算面积
{
    P o=P(0,0);
    P a=getP(o,s[0]);
    P b;
    ll res=0;
    for(int i=1;i<l-1;i++)
    {
        b=getP(a,s[i]);
        res+=cov(a,b);
        a=b;
    }
    if (res<0) return -res;
    else return res;
}
int main()
{
    int T;
    scanf("%d",&T);
    while(T--)
    {
        scanf("%s",&s);
        l=strlen(s);
        if (l==1) {printf("0\n");continue;}
        ll ans=solve();
        printf("%lld",ans/2);
        if (ans&1) printf(".5\n");
        else printf("\n");
    }
}
~~~



### 3.1判断点在矩形内

~~~c++
#include <iostream>
using namespace std;
//判断点(x,y) 是否在矩形内
struct P
{
	double x,y;
	P(){}
	P(double _x,double _y):x(_x),y(_y){}
};
P p1,p2,p3,p4,pp;//p1,p2,p3,p4 为矩形的四个顶点，pp是要判断的点。
double getCross(P& p1, P& p2,P& p)
{
	return (p2.x - p1.x) * (p.y - p1.y) - (p.x - p1.x) * (p2.y - p1.y);
}

bool isInter()
{
    if(getCross(p1,p2,pp) * getCross(p3,p4,pp) >= 0 && getCross(p2,p3,pp) * getCross(p4,p1,pp) >= 0) return true;
	return false;
}
~~~

### 3.2凸包

~~~c++
const int N=1e4+10,INF=1e9;
struct Node{int x,y;}p[N],s[N];
int n,top;
bool cmp(Node a,Node b)
{
    double A=atan2((a.y-p[1].y),(a.x-p[1].x));
    double B=atan2((b.y-p[1].y),(b.x-p[1].x));
    if (A!=B) return A<B;
    return a.x<b.x;
}
ll Cross(Node a,Node b,Node c)//计算叉积
{
    return 1LL*(b.x-a.x)*(c.y-a.y)-1LL*(b.y-a.y)*(c.x-a.x);
}
void get_convex_hull(int n,Node *p,Node *s)//p为所有的点，s为凸包上的点
{
    p[0]=(Node){INF,INF};
    int k;
    for(int i=1;i<=n;i++)
    {
        if (p[0].y>p[i].y || (p[0].y==p[i].y && p[0].x>p[i].x))
        {
            k=i;
            p[0]=p[i];
        }
    }
    std::swap(p[k],p[1]);
    std::sort(&p[2],&p[n+1],cmp);
    s[0]=p[1];
    s[1]=p[2];
    top=1;
    for(int i=3;i<=n;)
    {
        if (top && Cross(s[top-1],p[i],s[top])>=0)
            top--;
        else s[++top]=p[i++];
    }
//输出凸包上的所有点
//    for(int i=0;i<=top;i++)
//        printf("(%d,%d)\n",s[i].x,s[i].y);
//    printf("\n");
}
double dis(Node a,Node b)//计算两点的距离
{
    return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));
}
~~~

### 3.3覆盖问题

#### 3.3.1最小矩形覆盖

面积正确，求坐标的时候好像求错了。

~~~c++
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=1e5+10;
const double eps=1e-7,INF=1e11;
struct node{
    double x,y;
    node(){}
    node(double xx,double yy):x(xx),y(yy){}
    node operator +(const node &a)const 
	{
        return node(x+a.x,y+a.y);
    }
    node operator -(const node &a)const 
	{
        return node(x-a.x,y-a.y);
    }
    node operator *(const double &t)const//数乘 
	{
        return node(x*t,y*t);
    }
    double operator *(const node &a)const//点乘 
	{
        return x*a.x+y*a.y;
    } 
    double operator ^(const node &a)const//叉乘 
	{
        return x*a.y-y*a.x;
    }
    bool operator <(const node &a)const 
	{
        return fabs(y-a.y)<eps?x<a.x:y<a.y;
    }
    double mo(){return sqrt(x*x+y*y);}//模 
}p[N],s[N],t[4];
int n,top;
bool cmp(node a,node b)//犄角排序 
{
	double A=atan2(a.y-p[1].y,a.x-p[1].x);
	double B=atan2(b.y-p[1].y,b.x-p[1].x);
	return fabs(A-B)<eps?a.x<b.x:A<B;
}
void get_convex_hull(int n,node *p,node *s)
{
	p[0]=node(INF*1.0,INF*1.0);
	int k;
	for(int i=1;i<=n;i++)
	{
		if (p[i]<p[0]) k=i,p[0]=p[i];
	}
	swap(p[k],p[1]);
	sort(&p[2],&p[n+1],cmp);
	s[0]=p[1];
	s[1]=p[2];
	top=1;
	for(int i=3;i<=n;)
	{
		if (top && ((p[i]-s[top-1])^(s[top]-s[top-1]))>=0)
			top--;
		else s[++top]=p[i++];
	}
//	输出凸包上的点 
//	for(int i=0;i<=top;i++)
//		printf("(%.2lf,%.2lf)\n",s[i].x,s[i].y);
}
void solve(node *s)
{
	double ans=1e30;
	for(int i=1;i<=top;i++)
	{
		node l1=s[i]-s[i-1];
		double r=-INF,l=INF,h=-INF;
		for(int j=1;j<=n;j++)
		{
			node l2=p[j]-s[i-1];
			if (r<l2*l1/l1.mo()) r=l2*l1/l1.mo();
			if (l>l2*l1/l1.mo()) l=l2*l1/l1.mo();
			if ((l1^l2)/l1.mo()>h) h=(l1^l2)/l1.mo();
		}
		if (ans>(r-l)*h)
		{
			ans=(r-l)*h;
//			//求矩阵的坐标，逆时针方向 
//			node l1_e=l1*(1/l1.mo());//l1的单位向量
//			double c=sqrt(l1_e.y*l1_e.y/(l1_e.x*l1_e.x+l1_e.y*l1_e.y));
//			double d=sqrt(l1_e.x*l1_e.x/(l1_e.x*l1_e.x+l1_e.y*l1_e.y));
//			if (l1_e.y>0) c=-c;
//			if (l1_e.x<0) d=-d;
//			node T_e=node(c,d);//垂直l1的单位向量,在l1左边 
//			t[0]=l1_e*l+s[i-1];
//			t[1]=l1_e*r+s[i-1];
//			t[2]=T_e*h+t[1];
//			t[3]=T_e*h+t[0];
		} 
	}
	printf("%.5lf\n",ans);
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%lf%lf",&p[i].x,&p[i].y);
	}
	get_convex_hull(n,p,s);
	s[++top]=s[0];
	solve(s);
//	输出矩形的坐标 
//	int tmp=0;
//	for(int i=1;i<4;i++)
//	if (t[i]<t[tmp]) tmp=i;
//	for(int i=0;i<4;i++)
//		printf("%.5lf %.5lf\n",t[(i+tmp)%4].x,t[(i+tmp)%4].y);			
}
~~~



#### 3.3.2最小圆覆盖

红书

~~~c++

~~~



#### 3.3.3平行四边形覆盖

~~~c++
//平行四边形覆盖所有点
struct point {
	double x,y;
	friend bool operator<(const point &p1,const point &p2) {
		return p1.y<p2.y||(p1.y==p2.y&&p1.x<p2.x);
	}
}pt[N],res[N];
int n,m;
double height[N];
double dot(point p1,point p2) {
	return p1.x*p2.x+p1.y*p2.y;
}
double xmult(point p1,point p2,point p0){
	return (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);
}
double dist(point p1,point p2) {
	return sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y)+0.0);
}
double point_line_dist(point p,point l1,point l2) {
	return fabs(xmult(p,l1,l2))/dist(l1,l2);
}
bool ral(point p1,point p2,point p3) {
	return (p1.x-p2.x)*(p3.y-p2.y)-(p3.x-p2.x)*(p1.y-p2.y)<0;
}
int convexhull() {
	res[0]=pt[0];
	res[1]=pt[1];
	int top=1;
	for(int i=2;i<n;i++) {
		while(top&&ral(res[top-1],res[top],pt[i]))top--;
			res[++top]=pt[i];
		}
		int len=top;
		res[++top]=pt[n-2];
		for(int i=n-3;i>=0;i--) {
		while(top!=len&&ral(res[top-1],res[top],pt[i]))top--;
			res[++top]=pt[i];
	}
	return top;
}
int main() {
	int i,j,t,cas=0;
	point p1,p2,q1,q2,e1,e2;
	scanf("%d",&t);
	while(t--) {
		scanf("%d",&n);
		for(i=0;i<n;i++) scanf("%lf%lf",&pt[i].x,&pt[i].y);
		sort(pt,pt+n);
		int top=convexhull();
		for(i=0;i<top;i++) {
			height[i]=-1.0;
			for(j=0;j<top;j++)
				height[i]=max(height[i],point_line_dist(res[j],res[i],res[(i+1)%top]));
		}
		double ret=9999999999.9;
		for(i=0;i<top;i++)
		for(j=i+1;j<top;j++) {
            p1=res[i]; q1=res[(i+1)%top];
			p2=res[j]; q2=res[(j+1)%top];
			e1.x=q1.x-p1.x; e1.y=q1.y-p1.y;
			e2.x=q2.x-p2.x; e2.y=q2.y-p2.y;
			double jd=sin(acos(dot(e1,e2)/sqrt(dot(e1,e1)*dot(e2,e2))));
			if(jd<ep) continue;
			double s=height[i]*height[j]/jd;
			ret=min(ret,s);
		}
		printf("Swarm %d Parallelogram Area: %.4f\n",++cas,ret);
	}
}
~~~



### 3.4三角形

#### 3.4.1三角形的四心

~~~c++
struct Point{
    double x,y;
    Point(){}
    Point(double x,double y):x(x),y(y){}
    Point operator + (const Point &a)const{
        return Point(x+a.x,y+a.y);
    }
    Point operator - (const Point &a)const{
        return Point(x-a.x,y-a.y);
    }
    Point operator / (const double &t)const{
        return Point(x/t,y/t);
    }
    Point operator * (const double &t)const{
        return Point(x*t,y*t);
    }
};

struct Triangle{
    Point a,b,c;//三个点
    Triangle(){}
    Triangle(Point a,Point b,Point c):a(a),b(b),c(c){}
    //重心，三条中线的交点
    Point Gravity(){
        return (a+b+c)/3;
    }
    //内心，三角形内切圆的圆心，三条角平分线的交点
    Point Incenter(){
        Point cp;
        double la,lb,lc;
        la=(b-c).dis();
        lb=(c-a).dis();
        lc=(a-b).dis();
        cp.x=(la*a.x+lb*b.x+lc*c.x)/(la+lb+lc);
        cp.y=(la*a.y+lb*b.y+lc*c.y)/(la+lb+lc);
        return cp;
    }
    //外心，三角形外接圆的圆心，三条中垂线的交点
    Point Circum(){
        Point cp;
        double a1=b.x-a.x,b1=b.y-a.y,c1=(a1*a1+b1*b1)/2;
        double a2=c.x-a.x,b2=c.y-a.y,c2=(a2*a2+b2*b2)/2;
        double d=a1*b2-a2*b1;
        cp.x=a.x+(c1*b2-c2*b1)/d;
        cp.y=a.y+(a1*c2-a2*c1)/d;
        return cp;
    }
    //垂心，三条垂线的交点
    Point Ortho(){
        return Gravity()*3.0-Circum()*2.0;
    }
};


~~~



## 4、博弈

### 4.1SG函数

​		首先定义mex(minimal excludant)运算，这是施加于一个集合的运算，表示最小的不属于这个集合的非负整数。例如mex{0,1,2,4}=3、mex{2,3,5}=0、mex{}=0。
​		对于任意状态 x ， 定义 SG(x) = mex(S),其中 S 是 x 后继状态的SG函数值的集合。如 x  有三个后继状态分别为 SG(a),SG(b),SG(c)，那么SG(x) = mex{SG(a),SG(b),SG(c)}。 这样 集合S  的终态必然是空集，所以SG函数的终态为 SG(x) = 0,当且仅当 x 为必败点P时。

~~~c++
//f[N]:可改变当前状态的方式，N为方式的种类，f[N]要在getSG之前先预处理
//SG[]:0~n的SG函数值
//S[]:为x后继状态的集合
int f[N],SG[MAXN],S[MAXN];
void  getSG(int n){
    int i,j;
    memset(SG,0,sizeof(SG));
    //因为SG[0]始终等于0，所以i从1开始
    for(i = 1; i <= n; i++){
        //每一次都要将上一状态 的 后继集合 重置
        memset(S,0,sizeof(S));
        for(j = 0; f[j] <= i && j <= N; j++)
            S[SG[i-f[j]]] = 1;  //将后继状态的SG函数值进行标记
        for(j = 0;; j++) if(!S[j]){   //查询当前后继状态SG值中最小的非零值
            SG[i] = j;
            break;
        }
    }
}
~~~